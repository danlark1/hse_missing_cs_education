# gdb

В этой задаче Вам предстоит поработать с [GDB](https://www.gnu.org/software/gdb/) (GNU debugger)
и поковырять бинарники (как собранные с дебажными символами, так и без оных), чтобы
извлечь из них некоторую информацию.

Проверка осуществляется с помощью [Яндекс.Контеста](https://official.contest.yandex.ru/contest/31054/):
Вы должны отправить gdb скрипт, который будет запускаться поверх бинарей и
выдавать ответ на последней строке.

Поэтому последней командой всегда должен быть `print` или `p` какого-то числа
(кроме 4-го пункта).
Если Вы будете хитрить и выдавать числа, которые Вы списали или получили без
честного дебага (например, просто вывели `p $ANS`),
это будет вести к обнулению баллов всего контеста &mdash; проверка такого
жульничества будет ручной. Скрипты должны быть беспристрастны к изначальным
данным. Так, к сожалению, сделано из-за ограничений Яндекс.Контеста и моей
лени.

Беспристрастность данных означает следующее: пусть есть задача X, ответ на нее
12345. Запрещено отсылать скрипты, которые просто выводят этот ответ числом,
например, `p 12345`. То есть принимаются любые решения, которые нашли бы этот
12345, не зная ответ заранее, то есть адекватный и честный дебаг программы. Но,
например, разрешено делать continue на константу итераций, обращение к 10му
элемента массива или что-то ещё. Сами программы константы, относительные адреса
там стабильны. То есть если Вы получили ответ, Вы должны показать решением как
Вы его получили, отговорки вроде "он мне приснился", не принимаются.

Если говорить строго математически, то считайте, что входные данные контейнеров
или изначальные значения регистров могут быть рандомизированы, но константы
условия и относительные адреса программ остаются неизменными.

На сервере версия `gdb-7.10.1`, в целом любая современная версия gdb пойдёт для
локального тестирования.

### Оценка

Каждый пункт оценивается в 2.5 балла. Максимум можно получить 10 баллов.

### Задачи

1. `with_symbols`: Вам дана программа, собранная без оптимизации и с дебажными
символами. __Ответ__: значение переменной `x` после 10000-ой итерации цикла в
функции `f()`.
1. `without_symbols`: На этот раз программа собрана с оптимизацией и без
дебажной информации. Придётся немного освежить знание языка ассемблера.
__Ответ__: значение регистра `rax` после 10000-ой итерации цикла (прямо перед
`jne`) в функции `f()`.
1. `with_core`: Вам предстоит покопаться в кишках стандартного контейнера,
используя оставшийся после выполнения программы сoredump. К сожалению, сам
контейнер частично побился из-за того же бага, что уронил программу, но
гарантируется, что данные извлечь можно. __Ответ__: `hashmap[8888][1]`.
__Внимание: не используйте никакие функции типа квадратных скобок к векторам и
тд, только member access, С касты и арифметику указателей.__
1. `flaky`: Эта программа пытается посчитать ответ для Вас, но с очень большой
вероятностью падает на полпути. __Ответ__: то, что напечатает программа, если
добежит до конца.

**Автор всех задач проверил, что их сдать можно, если у Вас не сдаётся,
проблема скорее всего в Вас.**

### Тестирование

У каждой задачи ровно один тест с бинарным файлом и возможными coredump, Вы
должны отправить gdb скрипт, который решает данную задачу.
Скрипт будет тестироваться таким образом для первых трёх пунктов:

```console
$ gdb -q $BINARY_NAME $POSSIBLE_COREDUMP --batch -x $YOUR_SCRIPT_FILE 2>/dev/null | tail -n 1 | cut -f 3 -d ' '
```

В последнем пункте будет просто проверяться выведенное число программой.

Пояснение флагов:

*  `-q` это `quiet` мод, он не показывает версию gdb, делая вывод чуть более
   компактным
*  `--batch` это `batch` мод, который выходит из gdb shell, когда все команды
   были выполнены
*  `-x` лишь принимает файл с командами, которые выполняются

### Как решать

Я советую решать без флага `--batch` и `-x` &mdash; они нужны для тестирующей
системы. То есть, в идеале, Вы должны войти в gdb shell, подебагать, найти
нужное число, отправить файл с командами, как оно находилось.

Если у Вас на файл выводится `Permission denied`, это скорее всего означает, что
файл был скачан без executable бита. Если Вы не знаете, что это такое,
настоятельно рекомендую прочитать [Notation of traditional Unix
permissions](https://en.wikipedia.org/wiki/File-system_permissions#Notation_of_traditional_Unix_permissions).
Чтобы пофиксить эту проблему, используйте команду `chmod +x $FILE` (если
дословно, то "change mod with executable bit addition to $FILE").

### Используем docker

Все бинарники были собраны на ubuntu 18.04. Если у Вас стоит
достаточно свежий дистрибутив linux, то задачи можно решать на нём.

Для тех, у кого OSX, Windows или какой-то странный linux, мы собрали
докер образ с правильным окружением.

```
$ docker run --security-opt seccomp=unconfined -it darthslon/shad-cpp:gdb /bin/bash
root@a9bc09439be8:/# cd opt
root@a9bc09439be8:/opt# ls
coredump  flaky  with_core  with_symbols  without_symbols
```

### Полезные ссылки
* https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/hashtable.h
* https://www.gnu.org/software/gdb/
* https://en.wikibooks.org/wiki/X86_Assembly/GAS_Syntax
